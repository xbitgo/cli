package tpls

import (
	"bytes"
	"text/template"
)

const pbTpl = `// Code generated by xbit. DO NOT EDIT.
syntax = "proto3";

package {{.Package}};

import "google/api/gogo.proto";

option go_package = "{{.ProjectName}}/{{.PackagePath}};{{.Package}}";

{{ range .MessageList }}
message {{.Name}} {
	{{- range .MessageFields}}
	{{.Type}}  {{.Name}} = {{.Sort}} [json_name = "{{.JSONName}}", (gogoproto.moretags) = '{{- if ne .Validate ""}}{{.Validate}}{{- end}} label:"{{.Label}}"'];
	{{- end}}
}
{{ end }}
`

type Pb struct {
	ProjectName string
	SrcPath     string
	Import      string
	Package     string
	PackagePath string
	MessageList []Message
}

type Message struct {
	Name          string
	MessageFields []MessageField
}

type MessageField struct {
	Type       string // pb
	Type2      string // 原始
	Type3      string // 子
	ConvType   bool
	EntityType string
	PbType     string
	NoPoint    bool
	IsEntity   bool
	IsMuEntity bool
	Name       string
	Name2      string
	NameSn     string
	Sort       int
	JSONName   string
	Label      string
	Validate   string
}

func (s *Pb) Execute() ([]byte, error) {
	buf := new(bytes.Buffer)
	tmpl, err := template.New("GenPB").Parse(pbTpl)
	if err != nil {
		return nil, err
	}
	if err := tmpl.Execute(buf, s); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

const convPb = `// Code generated by xbit. DO NOT EDIT.
package converter

import (
	pb "{{.ProjectName}}/{{.PackagePath}}"
	"{{.Import}}"
	"github.com/xbitgo/core/tools/tool_time"
)

{{ range .MessageList}}
func From{{.Name}}Entity(input *entity.{{.Name}}) *pb.{{.Name}}{
	if input == nil {
		return nil
	}
	output := &pb.{{.Name}}{}
{{- range .MessageFields }}
	{{- if eq .Type2 "time.Time"}}
		{{- if .NoPoint}}
	output.{{.NameSn}} = tool_time.TimeToDateTimeString(input.{{.Name2}})
		{{- else}}
	output.{{.NameSn}} = tool_time.TimeToDateTimeString(*input.{{.Name2}})
		{{- end}}
	{{- else if .IsEntity}}
		{{- if .NoPoint}}
	output.{{.NameSn}} = From{{.Type}}Entity(&input.{{.Name2}})
		{{- else}}
	output.{{.NameSn}} = From{{.Type}}Entity(input.{{.Name2}})
		{{- end}}
	{{- else if .IsMuEntity}}
	output.{{.NameSn}} = make({{.PbType}},len(input.{{.Name2}}))
	for k, v := range input.{{.Name2}} {
		{{- if .NoPoint}}
		output.{{.NameSn}}[k] = From{{.Type3}}Entity(&v)
		{{- else}}
		output.{{.NameSn}}[k] = From{{.Type3}}Entity(v)
		{{- end}}
	}
	{{- else}}
	{{- if .ConvType}}
	output.{{.NameSn}} = {{.Type}}(input.{{.Name2}})
	{{- else}}
	{{- if eq .Name2 "Size"}} 
	output.{{.NameSn}}_ = input.{{.Name2}}
	{{- else}}
	output.{{.NameSn}} = input.{{.Name2}}
	{{- end}}
	{{- end}}
	{{- end}}
{{- end}}
	return output
}

func To{{.Name}}Entity(input *pb.{{.Name}}) *entity.{{.Name}}{
	if input == nil {
		return nil
	}
	output := &entity.{{.Name}}{}
{{- range .MessageFields }}
	{{- if eq .Type2 "time.Time"}} 
		{{- if .NoPoint}}
	output.{{.Name2}} = tool_time.ParseDateTime(input.{{.NameSn}})
		{{- else}}
	if ts := tool_time.ParseDateTime(input.{{.Name2}}); !ts.IsZero() {
		output.{{.Name2}} = &ts
	}
		{{- end}}
	{{- else if .IsEntity}}
		{{- if .NoPoint}}
	t{{.Name2}} := To{{.Type}}Entity(input.{{.NameSn}})
	if t{{.Name2}} != nil {
		output.{{.Name2}} = *t{{.Name2}}
	}
		{{- else}}
	output.{{.Name2}} = To{{.Type}}Entity(input.{{.NameSn}})
		{{- end}}
	{{- else if .IsMuEntity}}
	output.{{.Name2}} = make({{.EntityType}},len(input.{{.NameSn}}))
	for k, v := range input.{{.NameSn}} {
		{{- if .NoPoint}}
		t{{.Name2}} := To{{.Type3}}Entity(v)
		if t{{.Name2}} != nil {
			output.{{.Name2}}[k] = *t{{.Name2}}
		}
		{{- else}}
		output.{{.Name2}}[k] = To{{.Type3}}Entity(v)
		{{- end}}
	}
	{{- else}}
	{{- if .ConvType}}
	output.{{.Name2}} = {{.Type2}}(input.{{.NameSn}})
	{{- else}}
	{{- if eq .Name2 "Size"}} 
	output.{{.Name2}} = input.{{.NameSn}}_
	{{- else}}
	output.{{.Name2}} = input.{{.NameSn}}
	{{- end}}
	{{- end}}
	{{- end}}
{{- end}}
	return output
}

func From{{.Name}}List(input []*entity.{{.Name}}) []*pb.{{.Name}} {
	if input == nil {
		return nil
	}
	output := make([]*pb.{{.Name}}, 0, len(input))
	for _, item := range input {
		resultItem := From{{.Name}}Entity(item)
		output = append(output, resultItem)
	}
	return output
}

func To{{.Name}}List(input []*pb.{{.Name}}) []*entity.{{.Name}} {
	if input == nil || len(input) == 0 {
		return nil
	}
	output := make([]*entity.{{.Name}}, 0, len(input))
	for _, item := range input {
		resultItem := To{{.Name}}Entity(item)
		output = append(output, resultItem)
	}
	return output
}
{{end}}
`

func (s *Pb) ExecuteConv() ([]byte, error) {
	buf := new(bytes.Buffer)
	tmpl, err := template.New("PBConv").Parse(convPb)
	if err != nil {
		return nil, err
	}
	if err := tmpl.Execute(buf, s); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
